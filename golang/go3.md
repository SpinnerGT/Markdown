Sprintf: 返回格式化字符串

---
# 格式化:`%x.xv`

1.动词

![[Pasted image 20220123121730.png]]

> %#v与%v
> %#v可以显示一些值，如果不使用%#v的话，这些值可能会在输出中被隐藏
> ex:一个空字符串、一个制表符和一个换行符
> ![[../attachments/Pasted image 20220123122019.png]]

2.值宽度
![[Pasted image 20220123122135.png]]
- 最小宽度用空格补齐,如果省略的话，就不会添加任何空格
![[Pasted image 20220123122236.png]]

---

# 自己的函数

当调用当前包中定义的函数时，不应该指定包名

大小写问题

函数参数:
![[Pasted image 20220123122456.png]]

> 当函数运行时，每个参数都将被设置为对应参数中*值的副本*。然后这些参数值在函数块的代码中被使用


函数返回值:
![[Pasted image 20220123122729.png]]
当return语句运行时，函数立即退出，而不运行它后面的任何代码

> 你可以将其与if语句一起使用，在没有必要运行剩余代码的情况下（由于错误或一些其他情况）退出函数

==Go要求声明了返回类型的任何函数都必须以return语句结束==

## 多个返回值

需将返回值类型放在函数声明的第二组圆括号中（在函数参数的圆括号之后），用逗号分隔

要使返回值的目的更清楚，你可以为每个返回值提供名称
![[Pasted image 20220123152139.png]]

---

# 错误值

1.errors包/func New+ func Error
创建错误值的最简单方法是将字符串传递给errors包的New函数，该函数将返回一个新的错误值。如果对该错误值调用Error方法，将会得到传递给errors.New的字符串
![[Pasted image 20220123123025.png]]
```ad-tip
title: 智能

如果要将错误值传递给fmt或log包中的函数，则可能不需要调用它的Error方法。fmt和log中的函数已经被编写成能够检查是否传递给它们的值有Error方法，如果有，则打印Error的返回值
![[Pasted image 20220123123130.png]]
```

2.格式化输出错误信息`fmt.Errorf()`
> 不会打印或返回一个字符串，而是返回一个错误值
> ![[Pasted image 20220123123420.png]]


## 始终处理错误
当你调用返回错误值的函数时，在继续前行之前测试该值是否为nil是非常重要的。如果它不是nil，则意味着有一个错误必须进行处理。

> 否则就会继续使用错误数据(<0的油漆量)

解决方法:  => if 判断 err是否为nil
```go
amount, err := paintNeedde(4.2,-3.0)

if err != nil{
	//打印错误值:
	fmt.Println(err)
}else{//如果没错
	fmt.Println("%0.2f liters needed\n", amout)
}

....接着...

...
```
或者log.Fatal()终止并打印
```go
if err != nil{
	log.Fatal(err)
}

...继续..
```


# 值传递与指针传递

Go是一种“值传递”语言；函数形参从函数调用中接收实参的副本

```
表示变量地址的值称为指针
a := 10

mypointer = &a

指针:  *int //指向int的指针

取地址: &a  //取a的地址

取指针所指的值: *mypointer
更新指针的值:*myPointer = 8

```


如果函数接收一个指针作为参数，并更新该指针处的值，那么更新后的值在函数外部仍然可见