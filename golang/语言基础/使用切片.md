

```toc
```

# 赋值和切片

## 赋值
对切片里某个索引指向的元素赋值和对[[数组#^622562|数组里某个索引指向的元素赋值的方法]]完全一样

## 切片(类似python)

切片之所以被称为切片,是因为创建一个新的切片就是把底层数组切出一部分

### 2个索引[i:j]

![[Pasted image 20220115113034.png]]
![[Pasted image 20220115113043.png]]

```ad-note
newSlice 无法访问到它所指向的底层数组的第一个元素之前的部分。所以,对newSlice 来说,之前的那些元素就是不存在的
```
### 3个索引 [i:j:k]

第三个索引可以用来控制新切片的容量。其目的并不是要增加容量,而是要限制容量。可以看到,允许限制新切片的容量为底层数组提供了一定的保护,可以更好地控制追加操作

![[Pasted image 20220115155507.png]]





### 如何计算长度和容量

![[Pasted image 20220115113308.png]]

![[Pasted image 20220115155905.png]]

### 表示索引越界的语言运行时错误

切片有额外的容量是很好, 但是如果不能把这些容量合并到切片的长度里, 这些容量就没有用处。好在可以用 Go 语言的内置函数 append 来做这种合并很容易


# 切片增长

相对于数组而言, 使用切片的一个好处是, 可以按需增加切片的容量

Go 语言内置的[[append函数#切片中的append|append函数]]会处理增加长度时的所有操作细节

# 设置长度和容量一样的好处

我们之前讨论过, 内置函数 append 会首先使用可用容量。 一旦没有可用容量, 会分配一个新的底层数组。这导致很容易忘记切片间正在共享同一个底层数组。一旦发生这种情况,对切片进行修改,很可能会导致随机且奇怪的问题。对切片内容的修改会影响多个切片,却很难找到问题的原因。

如果在创建切片时设置切片的容量和长度一样,就可以强制让新切片的第一个 append 操作创建新的底层数组,与原有的底层数组分离。新切片与原有的底层数组分离后,可以安全地进行后续修改

![[Pasted image 20220115160354.png]]


# 迭代切片

既然切片是一个集合,可以迭代其中的元素,Go 语言有个特殊的[[range函数]] ,它可以配合关键字 for 来迭代切片里的元素

# 函数之间传递切片

复制时只会复制切片本身,不会涉及底层数组,所以在函数间复制和传递切片成本也很低

![[Pasted image 20220115163205.png]]